# 現状のイベントデータ管理について
現状、manageSceneObjectsやeventOccurCheckAndExecuteクラスは**クラス内部**でデータを生成している。  
しかし、これではmainクラスと以上の2つのクラスの結合度が高くなりすぎ再利用が難しい。  
従ってデータ生成とデータ管理を分離する必要がある。
## 現状どうやってデータを管理しているのか
eventOccurCheckAndExecuteクラスはmapで、manageSceneObjectsは**メンバ変数**で管理している。  
eventOccurCheckANdExecuteクラスは、データを内部のみで使用する。manageSceneObjectsクラスは**メンバ変数**に直接アクセスしてデータを使用する。  
## manageSceneObjectsの問題点
これが最大の問題である。  
現状先ほども言ったとおり、**メンバ変数**で管理している。  
これを分離するには**配列**に変更し、添え字でアクセスする必要がある。  
しかし添え字をいちいち覚えるのは非効率であるため、どこかに定数として定義しておく必要がある。  
現状は``DxLibProjectTemp.h``に置くが将来的には、シーンクラスを作成し置く必要があるだろう。  

## eventOccurCheckAndExecuteの問題点
イベントチェッククラスは**配列**で、イベントアクションクラスは**map**で管理されている。  
内部にデータを置く方法ではこれでも何ら問題はなかったが、外部からデータを受けるとなると話が変わってくる。  

まずイベントチェッククラスは**リスト**で管理する必要がある。  
イベントアクションクラスはそのままでいいだろう。  
# ちょっとその前に
managementSceneObjectsって本当にいるだろうか。  
そもそも、managementSceneObjectsクラスの立ち位置がはっきりしないのだ。このクラスは複数のクラス間でインスタンスを共有できるように作成されたものだが、playDisplayImageManagementはシーンクラスで生成したほうがいいし、userInputManagementクラスは、静的クラスにしてインスタンスの生成をしなくても関数を利用できるようにしたほうがいいだろう。  
そうなると、barクラスとballクラスしか残らないが、これだけであればクラス名を「画面上に表示するオブジェクトを管理するクラス」と「実際に画面更新処理を行うクラス」に分離したほうがいいのではないか。  
が、まだ問題が残る。イベントクラスである。イベントクラスはその特性上複数のクラスに対してアクセス(書き換えも時によっては行う)する必要がある。  
このような場合イベントクラスは、シーンクラスにアクセスして、必要なデータ(ポインタ、実体など)を取ってくる。  
このようにすることで、実際にどのようにデータをもつかという部分とアクセスする部分を分離することが出来る。  

以下、この案をUML図に表す。  
~~~plantuml
skinparam monochrome reverse
class objectsShowingOnDisplayManagement{

}

class updateObjectsShowingOnDisplay{

}
class eventClass{

}
class sceneClass{

}
~~~
eventClassはbarやballクラスにアクセスする際、sceneClassクラスを経由する。